import{S as r}from"./bLhfxamn.js";class l{constructor(e){Object.getOwnPropertyNames(e).forEach(t=>{Object.defineProperty(this,t,Object.getOwnPropertyDescriptor(e,t))}),this.unlocked=!this.reqs,this.notified=!1,this.assign&&(this.assign.count=0)}load(e){e.assignCount&&(this.assign.count=e.assignCount),e.count&&(this.count=e.count),e.notified&&(this.notified=e.notified),e.remainingSeconds&&(this.remainingSeconds=e.remainingSeconds),e.status&&(this.status=e.status)}getDataToSave(){let e={};return this.assign&&(e.assignCount=this.assign.count),this.notified&&(e.notified=this.notified),this.remainingSeconds&&(e.remainingSeconds=this.remainingSeconds),this.status&&(e.status=this.status),this.count&&(e.count=this.count),this.id&&(e.id=this.id),e}}const c=r({id:"game-store",state:()=>({elems:[],victory:!1,victoryReqs:null}),getters:{getElem:s=>e=>s.elems.find(o=>o.id==e),isVictoryReached:s=>s.victory?!1:!!(s.victoryReqs&&s.checkCounts(s.victoryReqs)),getCosts:s=>e=>e.costs,getInputs:s=>e=>e.inputs,getOutputs:s=>e=>e.outputs,getResults:s=>e=>e.results,getUpgrades:s=>e=>e.upgrades,getStorages:s=>e=>e.storages,checkCounts:s=>e=>{let o=!0;for(let t in e)s.getElem(t).count<e[t]&&(o=!1);return o},checkProds:s=>e=>{let o=!0;for(let t in e)s.getElem(t).prod<e[t]&&(o=!1);return o},checkResults:s=>e=>{let o=!0;for(let t in e){let i=s.getElem(t);i.count+e[t]>i.max&&(o=!1)}return o},getAvailableCount:s=>e=>{let t=s.getElem(e).count;return s.elems.filter(n=>n.assign&&n.assign.id==e&&n.assign.count>0).forEach(n=>t-=n.assign.count),t},checkAvailables:s=>e=>{let o=!0;for(let t in e)s.getAvailableCount(t)<e[t]&&(o=!1);return o}},actions:{loadScenario(s){this.elems=[],this.victory=!1,this.victoryReqs=s.victoryReqs,s.elems.forEach(t=>{let i=new l(t);this.elems.push(i)}),this.elems.filter(t=>t.type=="building").forEach(t=>{this.elems.filter(n=>n.assign&&n.assign.id==t.id).forEach(n=>{n.reqs=t.reqs,n.unlocked=!1})})},loadGameState(s){s.elems!=null&&s.elems.forEach(t=>{let i=this.getElem(t.id);i&&i.load(t)}),this.elems.filter(t=>t.reqs).forEach(t=>{t.unlocked=this.checkCounts(t.reqs)}),this.elems.filter(t=>t.assign&&t.assign.count>0).forEach(t=>{if(t.inputs)for(let i in t.inputs){let n=this.getElem(i);n.prod-=t.inputs[i]*t.assign.count,n.prod=Math.round(n.prod*100)/100}if(t.outputs)for(let i in t.outputs){let n=this.getElem(i);n.prod+=t.outputs[i]*t.assign.count,n.prod=Math.round(n.prod*100)/100}if(t.storages)for(let i in t.storages){let n=this.getElem(i);n.max+=t.storages[i]*t.assign.count,n.max=Math.round(n.max*100)/100}}),this.victory=this.checkCounts(this.victoryReqs)},computeOfflineProgress(s){this.doTick(s)},saveGameState(s){s.elems=[],this.elems.forEach(e=>s.elems.push(e.getDataToSave())),s.victory=this.victory},doTick(s){this.elems.filter(t=>t.status==="started").forEach(t=>{t.remainingSeconds-=s,t.remainingSeconds<=0&&this.onBuild(t)}),this.elems.filter(t=>t.prod>0&&t.count<t.max).forEach(t=>{t.count+=t.prod*s,t.count>=t.max&&(t.count=t.max)})},doVictory(){this.victory=!0},onBuild(s){s.status&&(s.status="waiting",s.remainingSeconds=0);let e=this.getResults(s);if(e)for(let t in e){let i=this.getElem(t);if(i.count>=i.max)continue;let n=e[t];i.count+=n,i.count>=i.max&&(i.count=i.max),i.count=Math.round(i.count*100)/100}this.elems.filter(t=>t.reqs).forEach(t=>{let i=this.checkCounts(t.reqs);i!=t.unlocked&&(t.unlocked=i,t.notified=!0)})}}});export{c as u};
